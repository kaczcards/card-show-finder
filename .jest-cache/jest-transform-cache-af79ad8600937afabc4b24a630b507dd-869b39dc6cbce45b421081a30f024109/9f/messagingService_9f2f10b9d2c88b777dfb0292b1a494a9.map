{"version":3,"names":["MessageType","MessageStatus","cov_sa5xt6wt7","s","sendMessage","_ref","_asyncToGenerator","senderId","recipientId","content","type","arguments","length","undefined","b","DIRECT","metadata","f","console","log","mockMessage","id","Date","now","status","SENT","createdAt","toISOString","updatedAt","error","_x","_x2","_x3","apply","getUserMessages","_ref2","userId","limit","offset","_x4","markMessageAsRead","_ref3","messageId","_x5","deleteMessage","_ref4","_x6","_x7","sendBroadcastMessage","_ref5","recipientIds","messages","message","BROADCAST","push","_x8","_x9","_x0","_x1","messagingService"],"sources":["messagingService.ts"],"sourcesContent":["/**\n * Messaging Service\n * \n * This service handles messaging functionality between users,\n * including notifications, direct messages, and broadcast messages.\n * \n * Note: This is currently a placeholder implementation.\n */\n\nimport { supabase } from '../supabase';\n\n// Message types\nexport enum MessageType {\n  DIRECT = 'direct',\n  BROADCAST = 'broadcast',\n  NOTIFICATION = 'notification',\n}\n\n// Message status\nexport enum MessageStatus {\n  SENT = 'sent',\n  DELIVERED = 'delivered',\n  READ = 'read',\n  FAILED = 'failed',\n}\n\n// Message interface\nexport interface Message {\n  id: string;\n  senderId: string;\n  recipientId: string;\n  content: string;\n  type: MessageType;\n  status: MessageStatus;\n  metadata?: Record<string, any>;\n  createdAt: Date | string;\n  updatedAt: Date | string;\n}\n\n/**\n * Send a message to a user\n * @param senderId ID of the sender\n * @param recipientId ID of the recipient\n * @param content Message content\n * @param type Message type\n * @param metadata Additional metadata\n * @returns The sent message or null if failed\n */\nexport const sendMessage = async (\n  senderId: string,\n  recipientId: string,\n  content: string,\n  type: MessageType = MessageType.DIRECT,\n  metadata?: Record<string, any>\n): Promise<Message | null> => {\n  try {\n    // This is a placeholder implementation\n    console.log('Sending message:', { senderId, recipientId, content, type, metadata });\n    \n    // In a real implementation, we would store the message in Supabase\n    // const { data, error } = await supabase\n    //   .from('messages')\n    //   .insert([{\n    //     sender_id: senderId,\n    //     recipient_id: recipientId,\n    //     content,\n    //     type,\n    //     status: MessageStatus.SENT,\n    //     metadata,\n    //     created_at: new Date().toISOString(),\n    //     updated_at: new Date().toISOString(),\n    //   }])\n    //   .select()\n    //   .single();\n    \n    // if (error) throw error;\n    \n    // For now, just return a mock message\n    const mockMessage: Message = {\n      id: `msg_${Date.now()}`,\n      senderId,\n      recipientId,\n      content,\n      type,\n      status: MessageStatus.SENT,\n      metadata,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n    \n    return mockMessage;\n  } catch (error) {\n    console.error('Error sending message:', error);\n    return null;\n  }\n};\n\n/**\n * Get messages for a user\n * @param userId ID of the user\n * @param limit Maximum number of messages to return\n * @param offset Offset for pagination\n * @returns Array of messages\n */\nexport const getUserMessages = async (\n  userId: string,\n  limit: number = 20,\n  offset: number = 0\n): Promise<Message[]> => {\n  try {\n    // This is a placeholder implementation\n    console.log('Getting messages for user:', userId);\n    \n    // In a real implementation, we would fetch messages from Supabase\n    // const { data, error } = await supabase\n    //   .from('messages')\n    //   .select('*')\n    //   .or(`recipient_id.eq.${userId},sender_id.eq.${userId}`)\n    //   .order('created_at', { ascending: false })\n    //   .range(offset, offset + limit - 1);\n    \n    // if (error) throw error;\n    \n    // Return empty array for now\n    return [];\n  } catch (error) {\n    console.error('Error getting user messages:', error);\n    return [];\n  }\n};\n\n/**\n * Mark a message as read\n * @param messageId ID of the message\n * @returns Success status\n */\nexport const markMessageAsRead = async (messageId: string): Promise<boolean> => {\n  try {\n    // This is a placeholder implementation\n    console.log('Marking message as read:', messageId);\n    \n    // In a real implementation, we would update the message in Supabase\n    // const { error } = await supabase\n    //   .from('messages')\n    //   .update({ status: MessageStatus.READ, updated_at: new Date().toISOString() })\n    //   .eq('id', messageId);\n    \n    // if (error) throw error;\n    \n    return true;\n  } catch (error) {\n    console.error('Error marking message as read:', error);\n    return false;\n  }\n};\n\n/**\n * Delete a message\n * @param messageId ID of the message\n * @param userId ID of the user (for verification)\n * @returns Success status\n */\nexport const deleteMessage = async (messageId: string, userId: string): Promise<boolean> => {\n  try {\n    // This is a placeholder implementation\n    console.log('Deleting message:', messageId);\n    \n    // In a real implementation, we would delete the message from Supabase\n    // const { error } = await supabase\n    //   .from('messages')\n    //   .delete()\n    //   .eq('id', messageId)\n    //   .or(`recipient_id.eq.${userId},sender_id.eq.${userId}`);\n    \n    // if (error) throw error;\n    \n    return true;\n  } catch (error) {\n    console.error('Error deleting message:', error);\n    return false;\n  }\n};\n\n/**\n * Send a broadcast message to multiple users\n * @param senderId ID of the sender\n * @param recipientIds Array of recipient IDs\n * @param content Message content\n * @param metadata Additional metadata\n * @returns Array of sent messages or null if failed\n */\nexport const sendBroadcastMessage = async (\n  senderId: string,\n  recipientIds: string[],\n  content: string,\n  metadata?: Record<string, any>\n): Promise<Message[] | null> => {\n  try {\n    // This is a placeholder implementation\n    console.log('Sending broadcast message:', { senderId, recipientIds, content, metadata });\n    \n    // In a real implementation, we would send individual messages to each recipient\n    const messages: Message[] = [];\n    for (const recipientId of recipientIds) {\n      const message = await sendMessage(\n        senderId,\n        recipientId,\n        content,\n        MessageType.BROADCAST,\n        metadata\n      );\n      if (message) {\n        messages.push(message);\n      }\n    }\n    \n    return messages;\n  } catch (error) {\n    console.error('Error sending broadcast message:', error);\n    return null;\n  }\n};\n\n// Export the messaging service\nexport const messagingService = {\n  sendMessage,\n  getUserMessages,\n  markMessageAsRead,\n  deleteMessage,\n  sendBroadcastMessage,\n};\n"],"mappings":"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","ignoreList":[]}